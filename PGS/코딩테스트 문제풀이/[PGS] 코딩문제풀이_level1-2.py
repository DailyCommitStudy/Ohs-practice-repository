### 코딩테스트 연습 > 연습문제 >
 
# 코딩테스트 level 1 

# 크기가 작은 부분문자열 (+2)
# 문제 설명 : 숫자로 이루어진 문자열 t와 p가 주어질 때, t에서 p와 길이가 같은 부분문자열 중에서, 
# 이 부분문자열이 나타내는 수가 p가 나타내는 수보다 작거나 같은 것이 나오는 횟수를 return하는 함수 solution을 완성하세요.

# 예를 들어, t="3141592"이고 p="271" 인 경우, t의 길이가 3인 부분 문자열은 314, 141, 415, 159, 592입니다. 
# 이 문자열이 나타내는 수 중 271보다 작거나 같은 수는 141, 159 2개 입니다.

# 제한사항 : 1 ≤ p의 길이 ≤ 18, p의 길이 ≤ t의 길이 ≤ 10,000, 
# t와 p는 숫자로만 이루어진 문자열이며, 0으로 시작하지 않습니다.

def solution(t, p):
    return len([t[i:i+len(p)] for i in range(len(t)-len(p)+1) if int(t[i:i+len(p)]) <= int(p)])



# 푸드 파이트 대회 (+1)
# 문제 설명 : 수웅이는 매달 주어진 음식을 빨리 먹는 푸드 파이트 대회를 개최합니다. 
# 이 대회에서 선수들은 1대 1로 대결하며, 매 대결마다 음식의 종류와 양이 바뀝니다. 
# 대결은 준비된 음식들을 일렬로 배치한 뒤, 한 선수는 제일 왼쪽에 있는 음식부터 오른쪽으로, 
# 다른 선수는 제일 오른쪽에 있는 음식부터 왼쪽으로 순서대로 먹는 방식으로 진행됩니다. 
# 중앙에는 물을 배치하고, 물을 먼저 먹는 선수가 승리하게 됩니다.

# 이때, 대회의 공정성을 위해 두 선수가 먹는 음식의 종류와 양이 같아야 하며, 음식을 먹는 순서도 같아야 합니다. 
# 또한, 이번 대회부터는 칼로리가 낮은 음식을 먼저 먹을 수 있게 배치하여 선수들이 음식을 더 잘 먹을 수 있게 하려고 합니다. 
# 이번 대회를 위해 수웅이는 음식을 주문했는데, 대회의 조건을 고려하지 않고 음식을 주문하여 몇 개의 음식은 대회에 사용하지 못하게 되었습니다.

# 예를 들어, 3가지의 음식이 준비되어 있으며, 칼로리가 적은 순서대로 1번 음식을 3개, 2번 음식을 4개, 3번 음식을 6개 준비했으며, 
# 물을 편의상 0번 음식이라고 칭한다면, 두 선수는 1번 음식 1개, 2번 음식 2개, 3번 음식 3개씩을 먹게 되므로 음식의 배치는 "1223330333221"이 됩니다.
# 따라서 1번 음식 1개는 대회에 사용하지 못합니다.

# 수웅이가 준비한 음식의 양을 칼로리가 적은 순서대로 나타내는 정수 배열 food가 주어졌을 때, 
# 대회를 위한 음식의 배치를 나타내는 문자열을 return 하는 solution 함수를 완성해주세요.

# 제한사항 : 2 ≤ food의 길이 ≤ 9, 1 ≤ food의 각 원소 ≤ 1,000
# food에는 칼로리가 적은 순서대로 음식의 양이 담겨 있습니다.
# food[i]는 i번 음식의 수입니다.
# food[0]은 수웅이가 준비한 물의 양이며, 항상 1입니다.
# 정답의 길이가 3 이상인 경우만 입력으로 주어집니다.

# my ver.
def solution(food):
    answer = ''
    for i in range(1, len(food)):
        food[i] = food[i] // 2
    for k in range(1, len(food)):
        answer += str(k) * food[k]
    final = answer + '0' + answer[::-1]
    return final

# other ver.
def solution(food):
    answer = ''
    foodSequence = [str(i+1)*(n//2) for i, n in enumerate(food[1:])]
    txt = ''.join(foodSequence)
    return txt+'0'+txt[::-1]
# enumerate 쓰는 노력을 해봐야겠다..!



# 가장 가까운 같은 글자 (+1)
# 문제 설명 : 문자열 s가 주어졌을 때, s의 각 위치마다 자신보다 앞에 나왔으면서, 자신과 가장 가까운 곳에 있는 같은 글자가 어디 있는지 알고 싶습니다.
# 예를 들어, s="banana"라고 할 때,  각 글자들을 왼쪽부터 오른쪽으로 읽어 나가면서 다음과 같이 진행할 수 있습니다.

# b는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
# a는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
# n은 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
# a는 자신보다 두 칸 앞에 a가 있습니다. 이는 2로 표현합니다.
# n도 자신보다 두 칸 앞에 n이 있습니다. 이는 2로 표현합니다.
# a는 자신보다 두 칸, 네 칸 앞에 a가 있습니다. 이 중 가까운 것은 두 칸 앞이고, 이는 2로 표현합니다.
# 따라서 최종 결과물은 [-1, -1, -1, 2, 2, 2]가 됩니다.

# 문자열 s이 주어질 때, 위와 같이 정의된 연산을 수행하는 함수 solution을 완성해주세요.

def solution(s):
    answer = []
    for i in range(len(s)):                    # 해당 문자열 길이만 큼 반복
        if s[i] in s[:i]:                      # 해당 문자가 현재 인덱스까지의 문자열에 존재한다면
            while s[:i].count(s[i]) > 1:       # 현재 인덱스까지의 문자열내에 여러개 존재한다면 1개가 남을때까지 반복
                s = s.replace(s[i], '0' ,1)    # 해당 문자 replace
            answer.append(i-s.index(s[i]))     # 가까운 해당 문자의 길이 출력
        else:                                  # 해당 문자가 현재 인덱스까지의 문자열에 존재하지 않는다면
            answer.append(-1)                  # -1 출력
    return answer